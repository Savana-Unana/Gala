<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Black Tie Gala - Wordle</title>
    <script>
      window.FIREBASE_CONFIG = {
        apiKey: "AIzaSyCcR537OUiw_M9iy29em6kBGfn-z7Tf7-8",
        authDomain: "gala-99db5.firebaseapp.com",
        projectId: "gala-99db5",
        storageBucket: "gala-99db5.firebasestorage.app",
        messagingSenderId: "75610830408",
        appId: "1:75610830408:web:111f50ea866528ac5a8a7d",
        measurementId: "G-7P75W73C4B"
      };
      window.EVENT_ID = "black-tie-gala-2026-02-09";
    </script>
    <style>
      :root {
        --bg-1: #0b0d12;
        --bg-2: #161b24;
        --bg-3: #0f141c;
        --gold-1: #f6d67b;
        --gold-2: #c9a44d;
        --ink: #e9eef6;
        --muted: #a6b3c6;
        --host: #ff8a5b;
        --aud: #5fd6a6;
        --ok: #63c174;
        --mid: #e0b44d;
        --no: #4c5566;
        --card: rgba(17, 20, 28, 0.85);
        --stroke: rgba(255, 255, 255, 0.08);
        --shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        color: var(--ink);
        font-family: "Fraunces", "Iowan Old Style", "Palatino Linotype", "Book Antiqua", "Times New Roman", serif;
        background:
          radial-gradient(1200px 600px at 80% -20%, rgba(246, 214, 123, 0.12), transparent 60%),
          radial-gradient(800px 500px at 10% 10%, rgba(255, 138, 91, 0.12), transparent 60%),
          linear-gradient(160deg, var(--bg-1), var(--bg-2) 40%, var(--bg-3));
        min-height: 100vh;
      }
      main { max-width: 1120px; margin: 0 auto; padding: 24px 16px 40px; }
      .glass {
        background: var(--card);
        border: 1px solid var(--stroke);
        border-radius: 16px;
        box-shadow: var(--shadow);
        padding: 14px;
      }
      .top { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; gap: 10px; }
      .top h1 { margin: 0; font-size: clamp(1.6rem, 4vw, 2.3rem); }
      .meta { display: flex; gap: 8px; align-items: center; font-family: "Work Sans", "Segoe UI", Arial, sans-serif; color: var(--muted); }
      .pill { border: 1px solid var(--stroke); border-radius: 999px; padding: 6px 10px; font-size: 0.82rem; }
      a.back { text-decoration: none; color: #151515; background: linear-gradient(135deg, var(--gold-1), var(--gold-2)); border-radius: 10px; padding: 8px 12px; font-family: "Work Sans", "Segoe UI", Arial, sans-serif; font-weight: 600; }
      .bar { display: grid; gap: 8px; margin-bottom: 12px; }
      .bar-labels { display: flex; justify-content: space-between; font-family: "Work Sans", "Segoe UI", Arial, sans-serif; color: var(--muted); font-size: 0.88rem; }
      .track { position: relative; height: 16px; border-radius: 999px; overflow: hidden; background: rgba(255, 255, 255, 0.1); }
      .meter { position: absolute; inset: 0; width: 0%; }
      .meter.host { background: linear-gradient(120deg, var(--host), #ffb18b); }
      .meter.aud { background: linear-gradient(120deg, var(--aud), #93e7c4); mix-blend-mode: screen; }
      .layout { display: grid; gap: 12px; grid-template-columns: minmax(0, 1fr) minmax(260px, 320px); }
      .word-info { margin-bottom: 10px; font-family: "Work Sans", "Segoe UI", Arial, sans-serif; color: var(--muted); }
      .board { display: grid; gap: 6px; }
      .guess { display: grid; gap: 6px; grid-template-columns: repeat(5, 1fr); }
      .tile {
        height: 44px;
        border-radius: 8px;
        border: 1px solid var(--stroke);
        display: grid;
        place-items: center;
        font-family: "Work Sans", "Segoe UI", Arial, sans-serif;
        font-weight: 700;
        text-transform: uppercase;
      }
      .tile.ok { background: rgba(99, 193, 116, 0.25); border-color: rgba(99, 193, 116, 0.5); }
      .tile.mid { background: rgba(224, 180, 77, 0.24); border-color: rgba(224, 180, 77, 0.5); }
      .tile.no { background: rgba(76, 85, 102, 0.35); border-color: rgba(76, 85, 102, 0.6); }
      .guess-input-row { display: flex; gap: 8px; margin-top: 10px; }
      .guess-input-row input {
        flex: 1;
        border: 1px solid var(--stroke);
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.25);
        color: var(--ink);
        padding: 8px 10px;
        font-family: "Work Sans", "Segoe UI", Arial, sans-serif;
      }
      .guess-input-row button {
        border: none;
        border-radius: 10px;
        padding: 8px 12px;
        font-family: "Work Sans", "Segoe UI", Arial, sans-serif;
        font-weight: 600;
        cursor: pointer;
        color: #151515;
        background: linear-gradient(135deg, var(--gold-1), var(--gold-2));
      }
      .side { display: grid; gap: 10px; }
      .timer { font-family: "Work Sans", "Segoe UI", Arial, sans-serif; font-size: 1.8rem; text-align: center; }
      .status { font-family: "Work Sans", "Segoe UI", Arial, sans-serif; color: var(--muted); font-size: 0.9rem; text-align: center; }
      .controls { display: grid; gap: 8px; }
      .controls button {
        border: none;
        border-radius: 10px;
        padding: 9px 10px;
        font-family: "Work Sans", "Segoe UI", Arial, sans-serif;
        font-weight: 600;
        cursor: pointer;
        color: #151515;
        background: linear-gradient(135deg, var(--gold-1), var(--gold-2));
      }
      .controls button.alt { background: rgba(255, 255, 255, 0.1); color: var(--ink); border: 1px solid var(--stroke); }
      .hidden { display: none; }
      @media (max-width: 880px) { .layout { grid-template-columns: 1fr; } }
      .qr-corner {
        position: fixed;
        right: 12px;
        bottom: 12px;
        width: 128px;
        padding: 8px;
        border-radius: 12px;
        border: 1px solid var(--stroke);
        background: rgba(10, 12, 18, 0.9);
        box-shadow: var(--shadow);
        z-index: 999;
      }
      .qr-corner img { width: 100%; height: auto; display: block; border-radius: 8px; }
      .qr-corner .qr-label {
        margin-bottom: 6px;
        text-align: center;
        color: var(--muted);
        font-family: "Work Sans", "Segoe UI", Arial, sans-serif;
        font-size: 0.72rem;
      }
    </style>
  </head>
  <body>
    <main>
      <div class="top">
        <h1>Wordle</h1>
        <div class="meta">
          <span class="pill" id="role-pill">Role</span>
          <a class="back" id="back-link" href="index.html">Back</a>
        </div>
      </div>

      <section class="bar glass">
        <div class="bar-labels">
          <span>Contestants: <strong id="host-score">0</strong></span>
          <span>Audience: <strong id="aud-score">0</strong></span>
        </div>
        <div class="track">
          <div class="meter host" id="host-meter"></div>
          <div class="meter aud" id="aud-meter"></div>
        </div>
        <div class="bar-labels">
          <span>Contestant Points: <strong id="host-points">0</strong></span>
          <span>Audience Points: <strong id="aud-points">0</strong></span>
        </div>
      </section>

      <section class="layout">
        <section class="glass" id="play-area">
          <div class="word-info" id="word-info"></div>
          <div class="board" id="board"></div>
          <div class="guess-input-row">
            <input id="guess-input" type="text" maxlength="5" autocomplete="off" placeholder="Enter guess and press Enter" />
            <button id="guess-submit" type="button">Submit</button>
          </div>
        </section>
        <aside class="side glass">
          <div class="timer" id="timer-display">02:00</div>
          <div class="status" id="status-line">Waiting for host.</div>
          <div class="status" id="rule-line">Audience target words: 7</div>

          <div class="controls hidden" id="host-controls">
            <button id="start-btn">Start Timer</button>
            <button class="alt" id="end-btn">End Timer</button>
            <button class="alt" id="reset-btn">Reset Round</button>
            <button id="add-host-point">+1 Contestants Point</button>
            <button id="add-aud-point">+1 Audience Point</button>
            <button class="alt" id="sub-host-point">-1 Contestants Point</button>
            <button class="alt" id="sub-aud-point">-1 Audience Point</button>
            <button class="alt" id="reset-stats-btn">Reset Stats</button>
          </div>
        </aside>
      </section>
    </main>
    <div class="qr-corner">
      <div class="qr-label">Scan This Page</div>
      <img src="qr.png" alt="QR code" />
    </div>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
      import {
        getFirestore,
        doc,
        setDoc,
        getDoc,
        updateDoc,
        runTransaction,
        onSnapshot,
        collection,
        serverTimestamp
      } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

      const params = new URLSearchParams(location.search);
      const contestantAccessId = window.CONTESTANT_ACCESS_ID || "contestant-1";
      const requestedRole = ["host", "contestant", "audience"].includes(params.get("role"))
        ? params.get("role")
        : "audience";
      const requestedId = params.get("id");
      const hostAuthorized = requestedRole === "host" && sessionStorage.getItem("gala_host_auth") === "1";
      const contestantAuthorized = requestedRole === "contestant" && requestedId === contestantAccessId;
      const role = hostAuthorized ? "host" : contestantAuthorized ? "contestant" : "audience";
      const resolveClientId = () => {
        if (role === "host") return requestedId || "host-control";
        if (role === "contestant") return contestantAccessId;
        const key = `gala-client-id-${role}`;
        const existing = localStorage.getItem(key);
        if (existing) return existing;
        const created = `${role}-${Math.random().toString(36).slice(2, 10)}`;
        localStorage.setItem(key, created);
        return created;
      };
      const clientId = resolveClientId();
      const rolePill = document.getElementById("role-pill");
      const backLink = document.getElementById("back-link");
      const playArea = document.getElementById("play-area");
      const hostControls = document.getElementById("host-controls");
      const wordInfo = document.getElementById("word-info");
      const boardEl = document.getElementById("board");
      const guessInput = document.getElementById("guess-input");
      const guessSubmit = document.getElementById("guess-submit");
      const timerDisplay = document.getElementById("timer-display");
      const statusLine = document.getElementById("status-line");
      const ruleLine = document.getElementById("rule-line");
      const hostScore = document.getElementById("host-score");
      const audScore = document.getElementById("aud-score");
      const hostMeter = document.getElementById("host-meter");
      const audMeter = document.getElementById("aud-meter");
      const hostPoints = document.getElementById("host-points");
      const audPoints = document.getElementById("aud-points");
      const roleLabel = role === "contestant" ? "Contestant Device" : role === "audience" ? "Audience Device" : "Host Control";
      rolePill.textContent = roleLabel;
      backLink.href = role === "host"
        ? "host.html"
        : role === "contestant"
          ? `index.html?id=${encodeURIComponent(contestantAccessId)}`
          : "index.html";
      if (role === "host") {
        playArea.classList.add("hidden");
        hostControls.classList.remove("hidden");
      }

      const firebaseConfig = window.FIREBASE_CONFIG || null;
      const eventId = window.EVENT_ID || "black-tie-gala";
      const localKey = `wordle:${role}:${clientId}`;
      const localState = JSON.parse(localStorage.getItem(localKey) || "{}");

      let gameState = null;
      let scoreState = { pointsContestants: 0, pointsAudience: 0 };
      let participants = [];
      let words = [];
      let wordIndex = Number(localState.wordIndex || 0);
      let solvedWords = Number(localState.solvedWords || 0);
      let guessesByWord = localState.guessesByWord || {};
      const wordCheckCache = new Map();
      let loadedToken = null;
      let hasSeenGameState = false;

      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);
      const gameRef = doc(db, "events", eventId, "games", "wordle");
      const scoreRef = doc(db, "events", eventId, "scoreboard", "global");
      const participantsRef = collection(gameRef, "participants");
      const participantRef = doc(participantsRef, `${role}-${clientId}`);

      const saveLocal = () => {
        localStorage.setItem(localKey, JSON.stringify({ wordIndex, solvedWords, guessesByWord }));
      };

      const activeWord = () => String(words[wordIndex] || "").toLowerCase();

      const isRealWord = async (word) => {
        if (wordCheckCache.has(word)) return wordCheckCache.get(word);
        let valid = false;
        try {
          const controller = new AbortController();
          const timer = setTimeout(() => controller.abort(), 1800);
          const res = await fetch(`https://api.datamuse.com/words?sp=${encodeURIComponent(word)}&max=1`, {
            signal: controller.signal
          });
          clearTimeout(timer);
          if (res.ok) {
            const payload = await res.json();
            valid = Array.isArray(payload) && payload.some((item) => String(item.word || "").toLowerCase() === word);
          }
        } catch (err) {
          valid = words.includes(word);
        }
        wordCheckCache.set(word, valid);
        return valid;
      };

      const seededRng = (seedText) => {
        let seed = 2166136261;
        for (let i = 0; i < seedText.length; i += 1) {
          seed ^= seedText.charCodeAt(i);
          seed = Math.imul(seed, 16777619);
        }
        return () => {
          seed += 0x6d2b79f5;
          let t = Math.imul(seed ^ (seed >>> 15), 1 | seed);
          t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      };

      const pickRandom = (pool, count, seedText) => {
        const arr = pool.slice();
        const rnd = seededRng(seedText);
        for (let i = arr.length - 1; i > 0; i -= 1) {
          const j = Math.floor(rnd() * (i + 1));
          const t = arr[i];
          arr[i] = arr[j];
          arr[j] = t;
        }
        return arr.slice(0, Math.max(0, Math.min(count, arr.length)));
      };

      const evaluate = (guess, target) => {
        const out = Array.from({ length: 5 }, (_, i) => ({ c: guess[i] || "", t: "no" }));
        const targetArr = target.split("");
        const used = Array(targetArr.length).fill(false);
        for (let i = 0; i < 5; i += 1) {
          if (guess[i] && guess[i] === targetArr[i]) {
            out[i].t = "ok";
            used[i] = true;
          }
        }
        for (let i = 0; i < 5; i += 1) {
          if (out[i].t === "ok") continue;
          for (let j = 0; j < targetArr.length; j += 1) {
            if (!used[j] && guess[i] === targetArr[j]) {
              out[i].t = "mid";
              used[j] = true;
              break;
            }
          }
        }
        return out;
      };

      const formatTime = (seconds) => {
        const s = Math.max(0, seconds);
        const m = Math.floor(s / 60);
        const r = s % 60;
        return `${String(m).padStart(2, "0")}:${String(r).padStart(2, "0")}`;
      };

      const getRemaining = () => {
        if (!gameState || gameState.timerStatus !== "running") return Number(gameState?.durationSec || 120);
        return Math.max(0, Math.ceil((Number(gameState.timerEndsAtMs || 0) - Date.now()) / 1000));
      };
      const isRoundActive = () => !!gameState && gameState.timerStatus === "running" && getRemaining() > 0;

      const aggregate = () => {
        const active = participants.filter((p) => Number(p.resetToken || 1) === Number(gameState?.resetToken || 1));
        const contestants = active.filter((p) => p.role === "contestant");
        const audience = active.filter((p) => p.role === "audience");
        return {
          contestantSolved: contestants.reduce((a, p) => a + Number(p.progress || 0), 0),
          audienceSolved: audience.reduce((a, p) => a + Number(p.progress || 0), 0)
        };
      };

      const renderBoard = () => {
        if (role === "host") return;
        if (!gameState || gameState.timerStatus !== "running") {
          boardEl.innerHTML = "<div class=\"status\">Round has not started yet.</div>";
          return;
        }
        const target = activeWord();
        const guesses = guessesByWord[wordIndex] || [];
        boardEl.innerHTML = "";
        guesses.forEach((g) => {
          const row = document.createElement("div");
          row.className = "guess";
          evaluate(g, target).forEach((cell) => {
            const tile = document.createElement("div");
            tile.className = `tile ${cell.t}`;
            tile.textContent = cell.c;
            row.appendChild(tile);
          });
          boardEl.appendChild(row);
        });
      };

      const syncProgress = async () => {
        if (role === "host") return;
        await setDoc(
          participantRef,
          {
            role,
            progress: solvedWords,
            resetToken: Number(gameState?.resetToken || 1),
            updatedAt: serverTimestamp()
          },
          { merge: true }
        );
      };

      const render = () => {
        if (!gameState) return;
        const totals = aggregate();
        const contestantProgress = role === "contestant"
          ? Math.max(totals.contestantSolved, solvedWords)
          : totals.contestantSolved;
        const audienceProgress = role === "audience"
          ? Math.max(totals.audienceSolved, solvedWords)
          : totals.audienceSolved;
        const audienceTarget = Number(gameState.audienceTargetWords || 7);

        hostScore.textContent = String(contestantProgress);
        audScore.textContent = String(audienceProgress);
        hostMeter.style.width = `${Math.min(100, contestantProgress * 100)}%`;
        audMeter.style.width = `${Math.min(100, (audienceProgress / Math.max(1, audienceTarget)) * 100)}%`;
        hostPoints.textContent = String(scoreState.pointsContestants || 0);
        audPoints.textContent = String(scoreState.pointsAudience || 0);
        timerDisplay.textContent = formatTime(getRemaining());
        ruleLine.textContent = `Audience target words: ${audienceTarget}`;

        if (role !== "host") {
          wordInfo.textContent = isRoundActive()
            ? `Word ${wordIndex + 1} of ${words.length}.`
            : "Waiting for host to start the round.";
          guessInput.disabled = !isRoundActive() || !activeWord();
          guessSubmit.disabled = guessInput.disabled;
        }

        let status = "Waiting for host.";
        if (gameState.timerStatus === "running" && getRemaining() > 0) status = "Round active.";
        if (gameState.timerStatus === "running" && getRemaining() <= 0) status = "Time is up. Waiting for host.";
        if (contestantProgress >= 1) status = "Contestants solved their word.";
        if (audienceProgress >= audienceTarget) status = "Audience reached target words.";
        if (gameState.timerStatus === "ended") {
          if (contestantProgress < 1) status = "Contestants failed to solve. Audience wins.";
          else if (audienceProgress >= audienceTarget) status = "Audience completed target first.";
          else status = "Contestants win this round.";
        }
        statusLine.textContent = status;
      };

      const submitGuess = async () => {
        if (role === "host") return;
        if (!isRoundActive()) return;
        const target = activeWord();
        const guess = guessInput.value.trim().toLowerCase();
        if (!target || guess.length !== target.length) return;
        if (!/^[a-z]{5}$/.test(guess)) {
          statusLine.textContent = "Use a 5-letter word.";
          return;
        }
        if (!(await isRealWord(guess))) {
          statusLine.textContent = `"${guess.toUpperCase()}" is not a valid dictionary word.`;
          return;
        }
        guessInput.value = "";
        guessesByWord[wordIndex] = guessesByWord[wordIndex] || [];
        if (guessesByWord[wordIndex].length >= 6) return;
        guessesByWord[wordIndex].push(guess);
        if (guess === target) {
          solvedWords += 1;
          wordIndex += 1;
        }
        saveLocal();
        renderBoard();
        await syncProgress();
        render();
      };

      const startRound = async () => {
        const durationSec = Number(gameState?.durationSec || 120);
        const now = Date.now();
        await updateDoc(gameRef, {
          timerStatus: "running",
          timerStartedAtMs: now,
          timerEndsAtMs: now + durationSec * 1000,
          updatedAt: serverTimestamp()
        });
      };

      const endRound = async () => {
        const totals = aggregate();
        const audienceTarget = Number(gameState?.audienceTargetWords || 7);
        await updateDoc(gameRef, {
          timerStatus: "ended",
          timerEndsAtMs: Date.now(),
          audienceTargetWords: audienceTarget,
          updatedAt: serverTimestamp()
        });
      };

      const resetRound = async () => {
        await updateDoc(gameRef, {
          timerStatus: "idle",
          timerStartedAtMs: null,
          timerEndsAtMs: null,
          resetToken: Date.now(),
          updatedAt: serverTimestamp()
        });
      };

      const resetStats = async () => {
        await updateDoc(gameRef, {
          audienceTargetWords: 7,
          wordSeed: Date.now(),
          resetToken: Date.now(),
          updatedAt: serverTimestamp()
        });
      };

      const addPoints = async (field, delta) => {
        await runTransaction(db, async (tx) => {
          const snap = await tx.get(scoreRef);
          const currentHost = Number(snap.data()?.pointsContestants || 0);
          const currentAud = Number(snap.data()?.pointsAudience || 0);
          const nextHost = field === "pointsContestants" ? Math.max(0, currentHost + delta) : currentHost;
          const nextAud = field === "pointsAudience" ? Math.max(0, currentAud + delta) : currentAud;
          if (!snap.exists()) {
            tx.set(scoreRef, {
              pointsContestants: nextHost,
              pointsAudience: nextAud,
              updatedAt: serverTimestamp()
            });
            return;
          }
          tx.update(scoreRef, {
            pointsContestants: nextHost,
            pointsAudience: nextAud,
            updatedAt: serverTimestamp()
          });
        });
      };

      document.getElementById("guess-submit")?.addEventListener("click", submitGuess);
      document.getElementById("guess-input")?.addEventListener("keydown", (e) => {
        if (e.key === "Enter") submitGuess();
      });
      document.getElementById("start-btn")?.addEventListener("click", startRound);
      document.getElementById("end-btn")?.addEventListener("click", endRound);
      document.getElementById("reset-btn")?.addEventListener("click", resetRound);
      document.getElementById("add-host-point")?.addEventListener("click", () => addPoints("pointsContestants", 1));
      document.getElementById("add-aud-point")?.addEventListener("click", () => addPoints("pointsAudience", 1));
      document.getElementById("sub-host-point")?.addEventListener("click", () => addPoints("pointsContestants", -1));
      document.getElementById("sub-aud-point")?.addEventListener("click", () => addPoints("pointsAudience", -1));
      document.getElementById("reset-stats-btn")?.addEventListener("click", resetStats);

      const loadWords = async () => {
        if (role === "host") return;
        const res = await fetch("wordle.json");
        const data = await res.json();
        const contestantWord = String(data.contestant_word || "galaa").toLowerCase();
        const audiencePool = Array.isArray(data.audience_pool) ? data.audience_pool : [];
        const perAudience = Number(data.audience_words_per_player || 10);
        const wordSeed = Number(gameState?.wordSeed || 1);

        if (role === "contestant") {
          words = [contestantWord];
          await setDoc(gameRef, { contestantWordCount: 1, updatedAt: serverTimestamp() }, { merge: true });
        } else {
          words = pickRandom(
            audiencePool.map((w) => String(w).toLowerCase()),
            perAudience,
            `${eventId}:${clientId}:wordle:${wordSeed}`
          );
        }
        if (!words.length) words = [contestantWord];
        renderBoard();
      };

      const initGame = async () => {
        const snap = await getDoc(gameRef);
        if (snap.exists()) return;
        await setDoc(gameRef, {
          durationSec: 120,
          timerStatus: "idle",
          timerStartedAtMs: null,
          timerEndsAtMs: null,
          pointsContestants: 0,
          pointsAudience: 0,
          audienceTargetWords: 7,
          wordSeed: 1,
          resetToken: 1,
          updatedAt: serverTimestamp()
        });
      };
      await initGame();

      onSnapshot(gameRef, async (snap) => {
        if (!snap.exists()) return;
        const prevToken = Number(gameState?.resetToken || 1);
        gameState = snap.data() || {};
        if (hasSeenGameState && Number(gameState.resetToken || 1) !== prevToken && role !== "host") {
          wordIndex = 0;
          solvedWords = 0;
          guessesByWord = {};
          loadedToken = null;
          words = [];
          saveLocal();
          renderBoard();
          await syncProgress();
        }
        hasSeenGameState = true;
        if (role !== "host") {
          const token = Number(gameState.resetToken || 1);
          if (gameState.timerStatus === "running" && loadedToken !== token) {
            await loadWords();
            loadedToken = token;
          }
          if (gameState.timerStatus !== "running" && loadedToken !== null) {
            loadedToken = null;
            words = [];
            renderBoard();
          }
        }
        render();
      });

      onSnapshot(participantsRef, (snap) => {
        participants = snap.docs.map((d) => d.data());
        render();
      });

      onSnapshot(scoreRef, (snap) => {
        const d = snap.data() || {};
        scoreState = {
          pointsContestants: Number(d.pointsContestants || 0),
          pointsAudience: Number(d.pointsAudience || 0)
        };
        render();
      });

      if (role !== "host") {
        renderBoard();
        await syncProgress();
      }
      setInterval(render, 300);
    </script>
  </body>
</html>
