<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Black Tie Gala - Word Ladder</title>
    <script>
      window.FIREBASE_CONFIG = {
        apiKey: "AIzaSyCcR537OUiw_M9iy29em6kBGfn-z7Tf7-8",
        authDomain: "gala-99db5.firebaseapp.com",
        projectId: "gala-99db5",
        storageBucket: "gala-99db5.firebasestorage.app",
        messagingSenderId: "75610830408",
        appId: "1:75610830408:web:111f50ea866528ac5a8a7d",
        measurementId: "G-7P75W73C4B"
      };
      window.EVENT_ID = "black-tie-gala-2026-02-09";
    </script>
    <style>
      :root {
        --bg-1: #0b0d12;
        --bg-2: #161b24;
        --bg-3: #0f141c;
        --gold-1: #f6d67b;
        --gold-2: #c9a44d;
        --ink: #e9eef6;
        --muted: #a6b3c6;
        --host: #ff8a5b;
        --aud: #5fd6a6;
        --card: rgba(17, 20, 28, 0.85);
        --stroke: rgba(255, 255, 255, 0.08);
        --shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        color: var(--ink);
        font-family: "Fraunces", "Iowan Old Style", "Palatino Linotype", "Book Antiqua", "Times New Roman", serif;
        background:
          radial-gradient(1200px 600px at 80% -20%, rgba(246, 214, 123, 0.12), transparent 60%),
          radial-gradient(800px 500px at 10% 10%, rgba(255, 138, 91, 0.12), transparent 60%),
          linear-gradient(160deg, var(--bg-1), var(--bg-2) 40%, var(--bg-3));
        min-height: 100vh;
      }
      main { max-width: 1120px; margin: 0 auto; padding: 24px 16px 40px; }
      .glass { background: var(--card); border: 1px solid var(--stroke); border-radius: 16px; box-shadow: var(--shadow); padding: 14px; }
      .top { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; gap: 10px; }
      .top h1 { margin: 0; font-size: clamp(1.6rem, 4vw, 2.3rem); }
      .meta { display: flex; gap: 8px; align-items: center; font-family: "Work Sans", "Segoe UI", Arial, sans-serif; color: var(--muted); }
      .pill { border: 1px solid var(--stroke); border-radius: 999px; padding: 6px 10px; font-size: 0.82rem; }
      a.back { text-decoration: none; color: #151515; background: linear-gradient(135deg, var(--gold-1), var(--gold-2)); border-radius: 10px; padding: 8px 12px; font-family: "Work Sans", "Segoe UI", Arial, sans-serif; font-weight: 600; }
      .bar { display: grid; gap: 8px; margin-bottom: 12px; }
      .bar-labels { display: flex; justify-content: space-between; font-family: "Work Sans", "Segoe UI", Arial, sans-serif; color: var(--muted); font-size: 0.88rem; }
      .track { position: relative; height: 16px; border-radius: 999px; overflow: hidden; background: rgba(255, 255, 255, 0.1); }
      .meter { position: absolute; inset: 0; width: 0%; }
      .meter.host { background: linear-gradient(120deg, var(--host), #ffb18b); }
      .meter.aud { background: linear-gradient(120deg, var(--aud), #93e7c4); mix-blend-mode: screen; }
      .layout { display: grid; gap: 12px; grid-template-columns: minmax(0, 1fr) minmax(260px, 320px); }
      .list { display: grid; gap: 10px; }
      .item {
        display: grid;
        grid-template-columns: 1fr 170px;
        gap: 8px;
        align-items: center;
        border: 1px solid var(--stroke);
        border-radius: 10px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.03);
      }
      .item input {
        width: 100%;
        border: 1px solid var(--stroke);
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.25);
        color: var(--ink);
        padding: 8px 10px;
        font-family: "Work Sans", "Segoe UI", Arial, sans-serif;
      }
      .item.solved { border-color: rgba(95, 214, 166, 0.45); background: rgba(95, 214, 166, 0.08); }
      .side { display: grid; gap: 10px; }
      .timer { font-family: "Work Sans", "Segoe UI", Arial, sans-serif; font-size: 1.8rem; text-align: center; }
      .status { font-family: "Work Sans", "Segoe UI", Arial, sans-serif; color: var(--muted); font-size: 0.9rem; text-align: center; }
      .controls { display: grid; gap: 8px; }
      .controls button {
        border: none;
        border-radius: 10px;
        padding: 9px 10px;
        font-family: "Work Sans", "Segoe UI", Arial, sans-serif;
        font-weight: 600;
        cursor: pointer;
        color: #151515;
        background: linear-gradient(135deg, var(--gold-1), var(--gold-2));
      }
      .controls button.alt { background: rgba(255, 255, 255, 0.1); color: var(--ink); border: 1px solid var(--stroke); }
      .hidden { display: none; }
      @media (max-width: 880px) { .layout { grid-template-columns: 1fr; } }
      .qr-corner {
        position: fixed;
        right: 12px;
        bottom: 12px;
        width: 128px;
        padding: 8px;
        border-radius: 12px;
        border: 1px solid var(--stroke);
        background: rgba(10, 12, 18, 0.9);
        box-shadow: var(--shadow);
        z-index: 999;
      }
      .qr-corner img { width: 100%; height: auto; display: block; border-radius: 8px; }
      .qr-corner .qr-label {
        margin-bottom: 6px;
        text-align: center;
        color: var(--muted);
        font-family: "Work Sans", "Segoe UI", Arial, sans-serif;
        font-size: 0.72rem;
      }
    </style>
  </head>
  <body>
    <main>
      <div class="top">
        <h1>Word Ladder</h1>
        <div class="meta">
          <span class="pill" id="role-pill">Role</span>
          <a class="back" id="back-link" href="index.html">Back</a>
        </div>
      </div>

      <section class="bar glass">
        <div class="bar-labels">
          <span>Contestants: <strong id="host-score">0</strong></span>
          <span>Audience: <strong id="aud-score">0</strong></span>
        </div>
        <div class="track">
          <div class="meter host" id="host-meter"></div>
          <div class="meter aud" id="aud-meter"></div>
        </div>
        <div class="bar-labels">
          <span>Contestant Points: <strong id="host-points">0</strong></span>
          <span>Audience Points: <strong id="aud-points">0</strong></span>
        </div>
      </section>

      <section class="layout">
        <section class="glass" id="play-area">
          <div class="list" id="ladder-list"></div>
        </section>
        <aside class="side glass">
          <div class="timer" id="timer-display">02:00</div>
          <div class="status" id="status-line">Waiting for host.</div>
          <div class="status" id="target-line">Audience target total: 70</div>
          <div class="controls hidden" id="host-controls">
            <button id="start-btn">Start Timer</button>
            <button class="alt" id="end-btn">End Timer</button>
            <button class="alt" id="reset-btn">Reset Round</button>
            <button id="add-host-point">+1 Contestants Point</button>
            <button id="add-aud-point">+1 Audience Point</button>
            <button class="alt" id="sub-host-point">-1 Contestants Point</button>
            <button class="alt" id="sub-aud-point">-1 Audience Point</button>
            <button class="alt" id="reset-stats-btn">Reset Stats</button>
          </div>
        </aside>
      </section>
    </main>
    <div class="qr-corner">
      <div class="qr-label">Scan This Page</div>
      <img src="qr.png" alt="QR code" />
    </div>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
      import {
        getFirestore,
        doc,
        setDoc,
        getDoc,
        updateDoc,
        runTransaction,
        onSnapshot,
        collection,
        serverTimestamp
      } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

      const params = new URLSearchParams(location.search);
      const contestantAccessId = window.CONTESTANT_ACCESS_ID || "contestant-1";
      const requestedRole = ["host", "contestant", "audience"].includes(params.get("role"))
        ? params.get("role")
        : "audience";
      const requestedId = params.get("id");
      const hostAuthorized = requestedRole === "host" && sessionStorage.getItem("gala_host_auth") === "1";
      const contestantAuthorized = requestedRole === "contestant" && requestedId === contestantAccessId;
      const role = hostAuthorized ? "host" : contestantAuthorized ? "contestant" : "audience";
      const resolveClientId = () => {
        if (role === "host") return requestedId || "host-control";
        if (role === "contestant") return contestantAccessId;
        const key = `gala-client-id-${role}`;
        const existing = localStorage.getItem(key);
        if (existing) return existing;
        const created = `${role}-${Math.random().toString(36).slice(2, 10)}`;
        localStorage.setItem(key, created);
        return created;
      };
      const clientId = resolveClientId();
      const rolePill = document.getElementById("role-pill");
      const backLink = document.getElementById("back-link");
      const playArea = document.getElementById("play-area");
      const hostControls = document.getElementById("host-controls");
      const listEl = document.getElementById("ladder-list");
      const timerDisplay = document.getElementById("timer-display");
      const statusLine = document.getElementById("status-line");
      const targetLine = document.getElementById("target-line");
      const hostScore = document.getElementById("host-score");
      const audScore = document.getElementById("aud-score");
      const hostMeter = document.getElementById("host-meter");
      const audMeter = document.getElementById("aud-meter");
      const hostPoints = document.getElementById("host-points");
      const audPoints = document.getElementById("aud-points");
      const roleLabel = role === "contestant" ? "Contestant Device" : role === "audience" ? "Audience Device" : "Host Control";
      rolePill.textContent = roleLabel;
      backLink.href = role === "host"
        ? "host.html"
        : role === "contestant"
          ? `index.html?id=${encodeURIComponent(contestantAccessId)}`
          : "index.html";
      if (role === "host") {
        playArea.classList.add("hidden");
        hostControls.classList.remove("hidden");
      }

      const firebaseConfig = window.FIREBASE_CONFIG || null;
      const eventId = window.EVENT_ID || "black-tie-gala";
      const localKey = `ladder:${role}:${clientId}`;
      const localState = JSON.parse(localStorage.getItem(localKey) || "{}");

      let gameState = null;
      let scoreState = { pointsContestants: 0, pointsAudience: 0 };
      let participants = [];
      let steps = [];
      let solved = localState.solved || {};
      let answers = localState.answers || {};
      let loadedToken = null;
      let hasSeenGameState = false;

      const seededRng = (seedText) => {
        let seed = 2166136261;
        for (let i = 0; i < seedText.length; i += 1) {
          seed ^= seedText.charCodeAt(i);
          seed = Math.imul(seed, 16777619);
        }
        return () => {
          seed += 0x6d2b79f5;
          let t = Math.imul(seed ^ (seed >>> 15), 1 | seed);
          t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      };

      const pickOne = (pool, seedText) => {
        if (!pool.length) return null;
        const rnd = seededRng(seedText);
        return pool[Math.floor(rnd() * pool.length)] || pool[0];
      };

      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);
      const gameRef = doc(db, "events", eventId, "games", "ladder");
      const scoreRef = doc(db, "events", eventId, "scoreboard", "global");
      const participantsRef = collection(gameRef, "participants");
      const participantRef = doc(participantsRef, `${role}-${clientId}`);

      const saveLocal = () => {
        localStorage.setItem(localKey, JSON.stringify({ solved, answers }));
      };
      const getMyProgress = () => Object.keys(solved).length;

      const formatTime = (seconds) => {
        const s = Math.max(0, seconds);
        const m = Math.floor(s / 60);
        const r = s % 60;
        return `${String(m).padStart(2, "0")}:${String(r).padStart(2, "0")}`;
      };
      const getRemaining = () => {
        if (!gameState || gameState.timerStatus !== "running") return Number(gameState?.durationSec || 120);
        return Math.max(0, Math.ceil((Number(gameState.timerEndsAtMs || 0) - Date.now()) / 1000));
      };
      const isRoundActive = () => !!gameState && gameState.timerStatus === "running" && getRemaining() > 0;

      const aggregate = () => {
        const active = participants.filter((p) => Number(p.resetToken || 1) === Number(gameState?.resetToken || 1));
        const contestants = active.filter((p) => p.role === "contestant");
        const audience = active.filter((p) => p.role === "audience");
        return {
          contestantProgress: contestants.reduce((a, p) => a + Number(p.progress || 0), 0),
          audienceProgress: audience.reduce((a, p) => a + Number(p.progress || 0), 0)
        };
      };

      const render = () => {
        if (!gameState) return;
        const totals = aggregate();
        const myProgress = getMyProgress();
        const contestantMax = Number(gameState.contestantMax || 15);
        const audienceMax = Number(gameState.audienceMaxTotal || 70);
        const contestantProgress = role === "contestant"
          ? Math.max(totals.contestantProgress, myProgress)
          : totals.contestantProgress;
        const audienceProgress = role === "audience"
          ? Math.max(totals.audienceProgress, myProgress)
          : totals.audienceProgress;

        hostScore.textContent = String(contestantProgress);
        audScore.textContent = String(audienceProgress);
        hostMeter.style.width = `${Math.min(100, (contestantProgress / Math.max(1, contestantMax)) * 100)}%`;
        audMeter.style.width = `${Math.min(100, (audienceProgress / Math.max(1, audienceMax)) * 100)}%`;
        hostPoints.textContent = String(scoreState.pointsContestants || 0);
        audPoints.textContent = String(scoreState.pointsAudience || 0);
        timerDisplay.textContent = formatTime(getRemaining());
        targetLine.textContent = `Audience target total: ${audienceMax}`;

        let status = "Waiting for host.";
        if (gameState.timerStatus === "running" && getRemaining() > 0) status = "Round active.";
        if (gameState.timerStatus === "running" && getRemaining() <= 0) status = "Time is up. Waiting for host.";
        if (contestantProgress >= contestantMax) status = "Contestants reached max.";
        if (audienceProgress >= audienceMax) status = "Audience reached max.";
        if (gameState.timerStatus === "ended") status = "Round ended.";
        statusLine.textContent = status;

        if (role !== "host") {
          const enabled = isRoundActive();
          listEl.querySelectorAll("input").forEach((input) => {
            input.disabled = !enabled;
          });
          if (!enabled && loadedToken === null) {
            listEl.innerHTML = "<div class=\"status\">Round has not started yet.</div>";
          }
        }
      };

      const syncProgress = async () => {
        if (role === "host") return;
        await setDoc(
          participantRef,
          {
            role,
            progress: getMyProgress(),
            resetToken: Number(gameState?.resetToken || 1),
            updatedAt: serverTimestamp()
          },
          { merge: true }
        );
      };

      const renderList = () => {
        if (role === "host") return;
        listEl.innerHTML = "";
        steps.forEach((step, idx) => {
          const row = document.createElement("div");
          row.className = "item";
          const hint = document.createElement("div");
          hint.textContent = idx === 0 ? `Start word: ${String(step.word || "").toUpperCase()}` : (step.hint || "");
          const input = document.createElement("input");
          input.type = "text";
          input.name = `ladder-${idx}`;
          input.autocomplete = "off";
          if (idx === 0) {
            input.value = String(step.word || "").toUpperCase();
            input.disabled = true;
            row.classList.add("solved");
          } else {
            input.value = answers[idx] || "";
            input.disabled = !isRoundActive();
          }
          if (solved[idx]) row.classList.add("solved");
          if (idx !== 0) {
            input.addEventListener("input", () => {
              if (!isRoundActive()) return;
              answers[idx] = input.value;
              const ok = input.value.trim().toLowerCase() === String(step.word || "").trim().toLowerCase();
              if (ok) solved[idx] = true;
              else delete solved[idx];
              row.classList.toggle("solved", ok);
              saveLocal();
              syncProgress();
              render();
            });
          }
          row.appendChild(hint);
          row.appendChild(input);
          listEl.appendChild(row);
        });
      };

      const loadSteps = async () => {
        if (role === "host") return;
        const res = await fetch("ladder.json");
        const data = await res.json();
        const contestantLadder = data.contestant_ladder || (data.contestant || data.host || [])[0] || { steps: [] };
        const audiencePool = data.audience_pool || data.audience || [];
        const ladder = role === "contestant"
          ? contestantLadder
          : pickOne(audiencePool, `${eventId}:${clientId}:ladder`) || { steps: [] };
        steps = ladder.steps || [];
        renderList();
        if (role === "contestant") {
          await setDoc(gameRef, { contestantMax: steps.length || 15, updatedAt: serverTimestamp() }, { merge: true });
        }
      };

      const startRound = async () => {
        const durationSec = Number(gameState?.durationSec || 120);
        const now = Date.now();
        await updateDoc(gameRef, {
          timerStatus: "running",
          timerStartedAtMs: now,
          timerEndsAtMs: now + durationSec * 1000,
          updatedAt: serverTimestamp()
        });
      };
      const endRound = async () => {
        await updateDoc(gameRef, {
          timerStatus: "ended",
          timerEndsAtMs: Date.now(),
          updatedAt: serverTimestamp()
        });
      };
      const resetRound = async () => {
        await updateDoc(gameRef, {
          timerStatus: "idle",
          timerStartedAtMs: null,
          timerEndsAtMs: null,
          resetToken: Date.now(),
          updatedAt: serverTimestamp()
        });
      };
      const resetStats = async () => {
        await updateDoc(gameRef, {
          resetToken: Date.now(),
          updatedAt: serverTimestamp()
        });
      };
      const addPoints = async (field, delta) => {
        await runTransaction(db, async (tx) => {
          const snap = await tx.get(scoreRef);
          const currentHost = Number(snap.data()?.pointsContestants || 0);
          const currentAud = Number(snap.data()?.pointsAudience || 0);
          const nextHost = field === "pointsContestants" ? Math.max(0, currentHost + delta) : currentHost;
          const nextAud = field === "pointsAudience" ? Math.max(0, currentAud + delta) : currentAud;
          if (!snap.exists()) {
            tx.set(scoreRef, {
              pointsContestants: nextHost,
              pointsAudience: nextAud,
              updatedAt: serverTimestamp()
            });
            return;
          }
          tx.update(scoreRef, {
            pointsContestants: nextHost,
            pointsAudience: nextAud,
            updatedAt: serverTimestamp()
          });
        });
      };

      document.getElementById("start-btn")?.addEventListener("click", startRound);
      document.getElementById("end-btn")?.addEventListener("click", endRound);
      document.getElementById("reset-btn")?.addEventListener("click", resetRound);
      document.getElementById("add-host-point")?.addEventListener("click", () => addPoints("pointsContestants", 1));
      document.getElementById("add-aud-point")?.addEventListener("click", () => addPoints("pointsAudience", 1));
      document.getElementById("sub-host-point")?.addEventListener("click", () => addPoints("pointsContestants", -1));
      document.getElementById("sub-aud-point")?.addEventListener("click", () => addPoints("pointsAudience", -1));
      document.getElementById("reset-stats-btn")?.addEventListener("click", resetStats);

      const initGame = async () => {
        const snap = await getDoc(gameRef);
        if (snap.exists()) return;
        await setDoc(gameRef, {
          durationSec: 120,
          timerStatus: "idle",
          timerStartedAtMs: null,
          timerEndsAtMs: null,
          pointsContestants: 0,
          pointsAudience: 0,
          contestantMax: 15,
          audienceMaxTotal: 70,
          resetToken: 1,
          updatedAt: serverTimestamp()
        });
      };
      await initGame();

      onSnapshot(gameRef, async (snap) => {
        if (!snap.exists()) return;
        const prevToken = Number(gameState?.resetToken || 1);
        gameState = snap.data() || {};
        if (hasSeenGameState && Number(gameState.resetToken || 1) !== prevToken && role !== "host") {
          solved = {};
          answers = {};
          loadedToken = null;
          steps = [];
          saveLocal();
          await syncProgress();
        }
        hasSeenGameState = true;
        if (role !== "host") {
          const token = Number(gameState.resetToken || 1);
          if (gameState.timerStatus === "running" && loadedToken !== token) {
            await loadSteps();
            loadedToken = token;
          }
          if (gameState.timerStatus !== "running" && loadedToken !== null) {
            loadedToken = null;
            steps = [];
            listEl.innerHTML = "<div class=\"status\">Round has not started yet.</div>";
          }
        }
        render();
      });

      onSnapshot(participantsRef, (snap) => {
        participants = snap.docs.map((d) => d.data());
        render();
      });

      onSnapshot(scoreRef, (snap) => {
        const d = snap.data() || {};
        scoreState = {
          pointsContestants: Number(d.pointsContestants || 0),
          pointsAudience: Number(d.pointsAudience || 0)
        };
        render();
      });

      if (role !== "host") {
        listEl.innerHTML = "<div class=\"status\">Round has not started yet.</div>";
        await syncProgress();
      }
      setInterval(render, 300);
    </script>
  </body>
</html>
